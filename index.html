<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>球球大作战 - 图片玩家球版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .game-shadow {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            }
            .pulse-glow {
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%, 100% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
                50% { box-shadow: 0 0 25px rgba(59, 130, 246, 0.8); }
            }
            .fade-in {
                animation: fadeIn 0.5s ease-in-out;
            }
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            .control-btn {
                @apply flex items-center justify-center rounded-full bg-white/10 backdrop-blur-sm border border-white/20 
                       text-white shadow-lg active:scale-95 transition-transform duration-100 touch-manipulation;
            }
            .pause-btn {
                @apply control-btn w-12 h-12 md:w-14 md:h-14 bg-primary/30 border-primary/50;
            }
            .joystick-container {
                @apply md:hidden w-32 h-32 bg-white/10 backdrop-blur-sm rounded-full border border-white/20 
                    flex items-center justify-center touch-manipulation z-20;
                position: absolute;
                display: none;
            }
            .joystick-knob {
                @apply w-16 h-16 bg-primary/40 rounded-full touch-manipulation transition-transform duration-100;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-dark to-slate-800 min-h-screen text-light flex flex-col items-center justify-center overflow-hidden p-2">
    <!-- 游戏容器 -->
    <div class="relative w-full max-w-6xl flex flex-col items-center">
        <!-- 游戏标题 -->
        <h1 class="text-[clamp(1.2rem,5vw,2.5rem)] font-bold mb-3 text-transparent bg-clip-text bg-gradient-to-r from-primary to-secondary text-center">
            球球大作战
        </h1>
        
        <!-- 游戏信息面板 -->
        <div class="w-full flex justify-between items-center mb-3 px-2 md:px-4 flex-wrap gap-2">
            <div class="bg-dark/70 backdrop-blur-sm rounded-lg px-3 py-1.5 flex items-center gap-1.5 border border-primary/30 text-sm md:text-base">
                <i class="fa fa-trophy text-yellow-400"></i>
                <span class="font-bold">得分: <span id="score" class="text-primary">0</span></span>
            </div>
            <div class="bg-dark/70 backdrop-blur-sm rounded-lg px-3 py-1.5 flex items-center gap-1.5 border border-primary/30 text-sm md:text-base">
                <i class="fa fa-circle text-danger"></i>
                <span class="font-bold">大小: <span id="size" class="text-primary">10</span></span>
            </div>
            <div class="bg-dark/70 backdrop-blur-sm rounded-lg px-3 py-1.5 flex items-center gap-1.5 border border-primary/30 text-sm md:text-base">
                <i class="fa fa-users text-secondary"></i>
                <span class="font-bold">敌人: <span id="enemy-count" class="text-primary">0</span></span>
            </div>
        </div>
        
        <!-- 游戏画布容器 -->
        <div class="relative w-full aspect-[9/16] md:aspect-[16/9] bg-slate-900 rounded-lg overflow-hidden game-shadow pulse-glow">
            <canvas id="gameCanvas" class="w-full h-full"></canvas>
            
            <!-- 暂停按钮 -->
            <div class="absolute top-4 right-4 z-20">
                <button id="pauseBtn" class="pause-btn" aria-label="暂停游戏">
                    <i class="fa fa-pause text-primary text-xl"></i>
                </button>
            </div>
            
            <!-- 功能按钮组 -->
            <div class="absolute bottom-6 right-6 flex flex-col gap-4 z-20">
                <button id="btnBoost" class="control-btn w-16 h-16 bg-danger/30 border-danger/40">
                    <i class="fa fa-bolt text-danger text-xl"></i>
                </button>
                <button id="btnRestart" class="control-btn w-16 h-16 bg-secondary/30 border-secondary/40">
                    <i class="fa fa-refresh text-secondary text-xl"></i>
                </button>
                <!-- 分球按钮（移动端右下角固定） -->
                <button id="btnSplit" class="md:hidden control-btn w-16 h-16 bg-primary/30 border-primary/60 text-white text-2xl shadow-lg active:scale-95 transition-transform mt-2" style="touch-action:manipulation;">
                    <i class="fa fa-share-alt"></i>
                </button>
            </div>

            <!-- 开始菜单 -->
            <div id="startMenu" class="absolute inset-0 bg-dark/80 backdrop-blur-md flex flex-col items-center justify-center gap-6 z-10 fade-in p-4">
                <h2 class="text-[clamp(1rem,3vw,1.8rem)] font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-primary to-secondary">
                    大球吃小球
                </h2>
                <p class="text-center px-4 max-w-md text-slate-300 text-sm md:text-base">
                    控制你的球吃掉比你小的球，避开比你大的球，成为最大的球！
                </p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 px-2 w-full max-w-md">
                    <div class="bg-slate-800/70 p-3 rounded-lg border border-primary/20 text-sm">
                        <h3 class="font-bold text-primary mb-1.5">控制方式</h3>
                        <ul class="text-slate-300 space-y-1">
                            <li><i class="fa fa-arrows mr-2 text-secondary"></i>电脑：方向键/WASD/鼠标</li>
                            <li><i class="fa fa-mobile mr-2 text-secondary"></i>手机：左下角摇杆控制方向</li>
                            <li><i class="fa fa-bolt mr-2 text-secondary"></i>右下角按钮：消耗大小加速</li>
                            <li><i class="fa fa-share-alt mr-2 text-secondary"></i>电脑按Q键/手机按分球按钮分球</li>
                            <li><i class="fa fa-pause mr-2 text-secondary"></i><strong>暂停键：</strong>右上角按钮或P键</li>
                        </ul>
                    </div>
                    <div class="bg-slate-800/70 p-3 rounded-lg border border-primary/20 text-sm">
                        <h3 class="font-bold text-primary mb-1.5">游戏目标</h3>
                        <ul class="text-slate-300 space-y-1">
                            <li><i class="fa fa-check-circle mr-2 text-secondary"></i>吃彩色小球增长</li>
                            <li><i class="fa fa-check-circle mr-2 text-secondary"></i>吃比你小的敌人</li>
                            <li><i class="fa fa-times-circle mr-2 text-danger"></i>避免被大球吃掉</li>
                        </ul>
                    </div>
                </div>
                <button id="startBtn" class="bg-primary hover:bg-primary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-primary/50 text-sm md:text-base">
                    开始游戏 <i class="fa fa-play ml-2"></i>
                </button>
            </div>
            
            <!-- 暂停菜单 -->
            <div id="pauseMenu" class="absolute inset-0 bg-dark/80 backdrop-blur-md flex flex-col items-center justify-center gap-6 z-10 hidden fade-in p-4">
                <h2 class="text-[clamp(1.2rem,4vw,2rem)] font-bold text-primary text-center">游戏暂停</h2>
                <p class="text-slate-300 text-center">休息一下，准备好再继续战斗吧！</p>
                <div class="flex gap-4">
                    <button id="resumeBtn" class="bg-primary hover:bg-primary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105">
                        继续游戏 <i class="fa fa-play ml-2"></i>
                    </button>
                    <button id="pauseRestartBtn" class="bg-secondary hover:bg-secondary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105">
                        重新开始 <i class="fa fa-refresh ml-2"></i>
                    </button>
                </div>
            </div>
            
            <!-- 游戏结束菜单 -->
            <div id="gameOverMenu" class="absolute inset-0 bg-dark/80 backdrop-blur-md flex flex-col items-center justify-center gap-5 z-10 hidden fade-in p-4">
                <h2 class="text-[clamp(1.2rem,4vw,2rem)] font-bold text-danger text-center">游戏结束</h2>
                <p class="text-base md:text-xl">最终得分: <span id="finalScore" class="text-primary font-bold">0</span></p>
                <p class="text-base md:text-xl">最终大小: <span id="finalSize" class="text-primary font-bold">0</span></p>
                <button id="gameOverRestartBtn" class="bg-primary hover:bg-primary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-primary/50 text-sm md:text-base">
                    再来一局 <i class="fa fa-refresh ml-2"></i>
                </button>
            </div>
            
            <!-- 移动设备虚拟摇杆 -->
            <div id="joystick" class="joystick-container">
                <div id="joystickKnob" class="joystick-knob"></div>
            </div>
        </div>
        
        <!-- 游戏控制说明 -->
        <div class="w-full mt-3 text-center text-xs md:text-sm text-slate-400">
            <p>电脑控制：<kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">W</kbd><kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">A</kbd><kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">S</kbd><kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">D</kbd> 或方向键移动，<kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">空格</kbd> 加速，<kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">Q</kbd> 分球，<kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">P</kbd> 暂停</p>
        </div>
    </div>

    <script>
        // 游戏主类
        class AgarioGame {
            constructor() {
                // 获取画布和上下文
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // 设备类型判断
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                // 加载玩家球图片（使用星球图片示例）
                this.playerImage = new Image();
                this.playerImage.src = 'https://picsum.photos/seed/playerball/200/200'; // 圆形星球图片
                this.imageLoaded = false;
                this.playerImage.onload = () => {
                    this.imageLoaded = true;
                };
                
                // 加载敌人图片组（用于替换其他玩家的圆形）
                this.enemyImages = [];
                this.enemyImagesLoaded = 0;
                this.enemyImagesCount = 5; // 准备5种不同敌人外观
                for (let i = 0; i < this.enemyImagesCount; i++) {
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.src = `https://picsum.photos/seed/enemy${i}/200/200`;
                    img.onload = () => {
                        this.enemyImagesLoaded++;
                    };
                    this.enemyImages.push(img);
                }
                
                // 设置画布尺寸
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // 游戏元素
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 10,
                    speed: this.isMobile ? 1.8 : 3,
                    maxSpeed: this.isMobile ? 3.2 : 6,
                    velocity: { x: 0, y: 0 },
                    invincible: false,
                    invincibilityTimer: 0,
                    score: 0
                };
                
                // 游戏配置 - 新增分球速度配置
                this.config = {
                    foodCount: this.isMobile ? 100 : 150,
                    enemyCount: this.isMobile ? 8 : 15,
                    foodMinRadius: 2,
                    foodMaxRadius: 6,
                    enemyMinRadius: 8,
                    enemyMaxRadius: 22,
                    invincibilityTime: 200,
                    boostConsumption: this.isMobile ? 0.015 : 0.02,
                    playerGrowthRate: 0.12,
                    enemyGrowthRate: this.isMobile ? 0.04 : 0.05,
                    splitSpeed: 4.5, // 降低分球速度，使分球更缓和（原值8）
                    splitSpeedVariation: 0.8 // 分球速度变化范围，增加自然感
                };
                
                // 游戏状态
                this.gameState = 'menu';
                this.gamePaused = false;
                // 世界与相机（地图比单个画面更大）
                this.worldWidth = this.canvas.width * 2;
                this.worldHeight = this.canvas.height * 2;
                this.camera = { x: 0, y: 0 };
                this.food = [];
                this.enemies = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.joystick = { 
                    active: false, 
                    startX: 0, 
                    startY: 0,
                    currentX: 0,
                    currentY: 0,
                    maxOffset: 40
                };
                this.splitBalls = []; // 存储玩家分裂球
                
                // 绑定DOM元素
                this.bindDOMElements();
                
                // 初始化游戏
                this.initGame();
                
                // 绑定事件监听
                this.bindEvents();
                
                // 游戏循环
                this.gameLoop();
            }
            
            // 绑定DOM元素
            bindDOMElements() {
                // 菜单和按钮元素
                this.startMenu = document.getElementById('startMenu');
                this.startBtn = document.getElementById('startBtn');
                this.pauseMenu = document.getElementById('pauseMenu');
                this.pauseBtn = document.getElementById('pauseBtn');
                this.resumeBtn = document.getElementById('resumeBtn');
                this.pauseRestartBtn = document.getElementById('pauseRestartBtn');
                this.gameOverMenu = document.getElementById('gameOverMenu');
                this.gameOverRestartBtn = document.getElementById('gameOverRestartBtn');

                // 功能按钮
                this.btnBoost = document.getElementById('btnBoost');
                this.btnRestart = document.getElementById('btnRestart');

                // 分球按钮（移动端固定右下角）
                this.btnSplit = document.getElementById('btnSplit');

                // 摇杆元素
                this.joystickElement = document.getElementById('joystick');
                this.joystickKnob = document.getElementById('joystickKnob');

                // 分数显示元素
                this.scoreDisplay = document.getElementById('score');
                this.sizeDisplay = document.getElementById('size');
                this.enemyCountDisplay = document.getElementById('enemy-count');
                this.finalScoreDisplay = document.getElementById('finalScore');
                this.finalSizeDisplay = document.getElementById('finalSize');
            }
            
            // 调整画布尺寸
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // 世界大小按画布扩大（保持世界至少为画布两倍）
                this.worldWidth = Math.max(this.worldWidth || 0, this.canvas.width * 2);
                this.worldHeight = Math.max(this.worldHeight || 0, this.canvas.height * 2);

                // 重新定位玩家到画布中心（初始或重置）
                if (this.gameState === 'playing' || this.gameState === 'paused' || this.gameState === 'menu') {
                    this.player.x = Math.min(Math.max(this.player.x, this.player.radius), this.worldWidth - this.player.radius);
                    this.player.y = Math.min(Math.max(this.player.y, this.player.radius), this.worldHeight - this.player.radius);
                    // 重置摄像机以玩家为中心
                    this.camera.x = this.player.x - this.canvas.width / 2;
                    this.camera.y = this.player.y - this.canvas.height / 2;
                    this.clampCamera();
                }
            }
            
            // 初始化游戏
            initGame() {
                // 重置玩家
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 10,
                    speed: this.isMobile ? 1.8 : 3,
                    maxSpeed: this.isMobile ? 3.2 : 6,
                    velocity: { x: 0, y: 0 },
                    invincible: false,
                    invincibilityTimer: 0,
                    score: 0
                };
                
                // 清空分裂球
                this.splitBalls = [];
                
                // 生成食物
                this.food = [];
                for (let i = 0; i < this.config.foodCount; i++) {
                    this.spawnFood();
                }
                
                // 生成敌人
                this.enemies = [];
                for (let i = 0; i < this.config.enemyCount; i++) {
                    this.spawnEnemy();
                }
                
                // 更新UI
                this.updateUI();
            }
            
            // 生成食物
            spawnFood() {
                const radius = this.config.foodMinRadius + Math.random() * (this.config.foodMaxRadius - this.config.foodMinRadius);
                const x = radius + Math.random() * (this.worldWidth - 2 * radius);
                const y = radius + Math.random() * (this.worldHeight - 2 * radius);
                
                // 随机颜色
                const hue = Math.random() * 360;
                const color = `hsl(${hue}, 70%, 60%)`;
                
                this.food.push({ x, y, radius, color });
            }
            
            // 生成敌人
            spawnEnemy() {
                const radius = this.config.enemyMinRadius + Math.random() * (this.config.enemyMaxRadius - this.config.enemyMinRadius);
                let x, y;
                
                // 确保敌人不会出现在玩家附近
                do {
                    x = radius + Math.random() * (this.worldWidth - 2 * radius);
                    y = radius + Math.random() * (this.worldHeight - 2 * radius);
                } while (this.getDistance({x, y}, this.player) < this.player.radius + radius + 50);
                
                // 随机颜色
                const hue = 120 + Math.random() * 60;
                const color = this.isMobile ? `hsl(${hue}, 80%, 45%)` : `hsl(${hue}, 70%, 50%)`;
                
                // 敌人速度
                const enemySpeed = this.isMobile ? (0.6 + Math.random() * 0.9) : (1 + Math.random() * 1.5);
                
                this.enemies.push({
                    x, y, radius, color,
                    speed: enemySpeed,
                    velocity: { x: 0, y: 0 },
                    target: null,
                    imageIndex: Math.floor(Math.random() * this.enemyImagesCount),
                    splitBalls: [] // 敌人分裂球
                });
            }
            
            // 绑定事件监听
            bindEvents() {
                // 移除旧事件监听
                this.startBtn.removeEventListener('click', this.startGame.bind(this));
                this.pauseBtn.removeEventListener('click', this.togglePause.bind(this));
                this.resumeBtn.removeEventListener('click', this.resumeGame.bind(this));
                this.pauseRestartBtn.removeEventListener('click', this.restartGame.bind(this));
                this.gameOverRestartBtn.removeEventListener('click', this.restartGame.bind(this));
                this.btnRestart.removeEventListener('click', this.restartGame.bind(this));
                this.btnBoost.removeEventListener('touchstart', this.handleBoostStart.bind(this));
                this.btnBoost.removeEventListener('mousedown', this.handleBoostStart.bind(this));
                this.btnBoost.removeEventListener('touchend', this.handleBoostEnd.bind(this));
                this.btnBoost.removeEventListener('mouseup', this.handleBoostEnd.bind(this));
                this.btnBoost.removeEventListener('mouseleave', this.handleBoostEnd.bind(this));
                
                // 绑定核心按钮事件
                this.startBtn.addEventListener('click', this.startGame.bind(this));
                this.pauseBtn.addEventListener('click', this.togglePause.bind(this));
                this.resumeBtn.addEventListener('click', this.resumeGame.bind(this));
                this.pauseRestartBtn.addEventListener('click', this.restartGame.bind(this));
                this.gameOverRestartBtn.addEventListener('click', this.restartGame.bind(this));
                this.btnRestart.addEventListener('click', this.restartGame.bind(this));
                
                // 加速按钮事件
                this.btnBoost.addEventListener('touchstart', this.handleBoostStart.bind(this), { passive: false });
                this.btnBoost.addEventListener('mousedown', this.handleBoostStart.bind(this));
                this.btnBoost.addEventListener('touchend', this.handleBoostEnd.bind(this), { passive: false });
                this.btnBoost.addEventListener('mouseup', this.handleBoostEnd.bind(this));
                this.btnBoost.addEventListener('mouseleave', this.handleBoostEnd.bind(this));

                // 分球按钮事件（移动端）
                if (this.btnSplit) {
                    this.btnSplit.addEventListener('touchstart', (e) => { e.preventDefault(); this.splitAllBalls(); }, { passive: false });
                    this.btnSplit.addEventListener('mousedown', (e) => { e.preventDefault(); this.splitAllBalls(); });
                }
                
                // 键盘控制（电脑端）
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === 'p' || e.key === 'P') {
                        this.togglePause();
                    }
                    if (e.key === 'q' || e.key === 'Q') {
                        this.splitAllBalls(); // 修改为分所有球
                    }
                });
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });

                // 鼠标控制（电脑端）
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouse.down = true;
                    this.updateMousePosition(e);
                });
                this.canvas.addEventListener('mousemove', (e) => {
                    this.updateMousePosition(e);
                });
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });
                this.canvas.addEventListener('mouseleave', () => {
                    this.mouse.down = false;
                });
            }

            // 更新鼠标位置（电脑端控制）
            updateMousePosition(e) {
                const rect = this.canvas.getBoundingClientRect();
                // 将鼠标位置转换为游戏世界坐标
                this.mouse.x = e.clientX - rect.left + this.camera.x;
                this.mouse.y = e.clientY - rect.top + this.camera.y;
            }
            
            // 分球主函数 - 改为分所有球
            splitAllBalls() {
                // 先保存当前分裂球，避免在循环中修改数组
                const currentBalls = [...this.splitBalls];
                
                // 玩家主球分球
                this.splitSingleBall(this.player);
                
                // 所有分裂球分球
                currentBalls.forEach(ball => {
                    this.splitSingleBall(ball);
                });
            }
            
            // 单个球分球功能
            splitSingleBall(ball) {
                // 检查是否可以分球
                if (!ball || ball.radius < 18) return;
                const minR = 10;
                const splitR = Math.max(ball.radius / 2, minR);
                if (ball.radius < splitR + minR) return;
                
                // 确定分球方向
                let angle = this.determineSplitAngle(ball);
                
                // 为两个分裂球计算略微不同的角度，使它们分开
                const angle1 = angle - 0.1; // 角度偏移，使分球更自然
                const angle2 = angle + 0.1;
                
                // 计算分球速度，增加一点随机性使分球更缓和自然
                const baseSpeed = this.config.splitSpeed;
                const speedVariation = this.config.splitSpeedVariation;
                const speed1 = baseSpeed + (Math.random() * speedVariation * 2 - speedVariation);
                const speed2 = baseSpeed + (Math.random() * speedVariation * 2 - speedVariation);
                
                // 第一个分球
                const dist1 = ball.radius + splitR + 1;
                const nx1 = ball.x + Math.cos(angle1) * dist1;
                const ny1 = ball.y + Math.sin(angle1) * dist1;
                const nvx1 = Math.cos(angle1) * speed1;
                const nvy1 = Math.sin(angle1) * speed1;
                
                // 第二个分球
                const dist2 = ball.radius + splitR + 1;
                const nx2 = ball.x + Math.cos(angle2) * dist2;
                const ny2 = ball.y + Math.sin(angle2) * dist2;
                const nvx2 = Math.cos(angle2) * speed2;
                const nvy2 = Math.sin(angle2) * speed2;
                
                // 添加新的分裂球
                this.splitBalls.push({
                    x: nx1,
                    y: ny1,
                    radius: splitR,
                    velocity: { x: nvx1, y: nvy1 },
                    timer: 30
                });
                
                this.splitBalls.push({
                    x: nx2,
                    y: ny2,
                    radius: splitR,
                    velocity: { x: nvx2, y: nvy2 },
                    timer: 30
                });
                
                // 从原球移除质量
                if (ball === this.player) {
                    // 主球分球
                    this.player.radius -= splitR * 2;
                } else {
                    // 分裂球分球 - 从数组中移除原分裂球
                    const index = this.splitBalls.indexOf(ball);
                    if (index !== -1) {
                        this.splitBalls.splice(index, 1);
                    }
                }
            }
            
            // 确定分球方向
            determineSplitAngle(ball) {
                let angle = 0;
                
                // 如果是主球，根据当前移动方向确定分球方向
                if (ball === this.player) {
                    if (this.isMobile && this.joystick.active) {
                        const dx = this.joystick.currentX - this.joystick.startX;
                        const dy = this.joystick.currentY - this.joystick.startY;
                        if (dx !== 0 || dy !== 0) {
                            angle = Math.atan2(dy, dx);
                        } else {
                            angle = Math.random() * Math.PI * 2;
                        }
                    } else if (!this.isMobile) {
                        // 电脑端控制
                        let moveX = 0, moveY = 0;
                        if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) moveY = -1;
                        if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) moveY = 1;
                        if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) moveX = -1;
                        if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) moveX = 1;
                        
                        if (moveX !== 0 || moveY !== 0) {
                            angle = Math.atan2(moveY, moveX);
                        } else if (this.mouse.down) {
                            const dx = this.mouse.x - this.player.x;
                            const dy = this.mouse.y - this.player.y;
                            if (dx !== 0 || dy !== 0) {
                                angle = Math.atan2(dy, dx);
                            } else {
                                angle = Math.random() * Math.PI * 2;
                            }
                        } else {
                            angle = Math.random() * Math.PI * 2;
                        }
                    }
                } else {
                    // 分裂球分球方向：沿当前移动方向
                    if (ball.velocity.x !== 0 || ball.velocity.y !== 0) {
                        angle = Math.atan2(ball.velocity.y, ball.velocity.x);
                    } else {
                        angle = Math.random() * Math.PI * 2;
                    }
                }
                
                return angle;
            }
            
            // 更新分裂球运动
            updateSplitBalls() {
                if (!this.splitBalls) return;
                for (let i = this.splitBalls.length - 1; i >= 0; i--) {
                    const ball = this.splitBalls[i];
                    if (ball.timer > 0) {
                        ball.x += ball.velocity.x;
                        ball.y += ball.velocity.y;
                        // 分裂球逐渐减速
                        ball.velocity.x *= 0.98;
                        ball.velocity.y *= 0.98;
                        ball.timer--;
                    } else {
                        // 分裂球向主球移动
                        const dx = ball.x - this.player.x;
                        const dy = ball.y - this.player.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < this.player.radius + ball.radius + 2) {
                            this.player.radius += ball.radius;
                            this.splitBalls.splice(i, 1);
                        } else {
                            const angle = Math.atan2(this.player.y - ball.y, this.player.x - ball.x);
                            // 移动速度随距离增加而增加
                            const moveSpeed = Math.min(2, dist / 50);
                            ball.x += Math.cos(angle) * moveSpeed;
                            ball.y += Math.sin(angle) * moveSpeed;
                        }
                    }
                }
            }
            
            // 绑定摇杆事件
            bindJoystickEvents() {
                // 触摸开始：把摇杆容器移动到触点处并显示
                this.joystickElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    this.joystick.identifier = touch.identifier;

                    // 在触点处放置摇杆容器
                    const size = this.joystickElement.getBoundingClientRect();
                    const left = touch.clientX - size.width / 2;
                    const top = touch.clientY - size.height / 2;
                    this.joystickElement.style.left = `${left}px`;
                    this.joystickElement.style.top = `${top}px`;
                    this.joystickElement.style.display = 'flex';

                    // 中心点
                    this.joystick.startX = touch.clientX;
                    this.joystick.startY = touch.clientY;
                    this.joystick.currentX = touch.clientX;
                    this.joystick.currentY = touch.clientY;
                    this.joystick.active = true;
                }, { passive: false });

                this.joystickElement.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.joystick.active) return;
                    // 找到对应触点
                    let touch = null;
                    for (let i = 0; i < e.touches.length; i++) {
                        if (e.touches[i].identifier === this.joystick.identifier) { touch = e.touches[i]; break; }
                    }
                    if (!touch) return;

                    this.joystick.currentX = touch.clientX;
                    this.joystick.currentY = touch.clientY;

                    const dx = this.joystick.currentX - this.joystick.startX;
                    const dy = this.joystick.currentY - this.joystick.startY;
                    const distance = Math.min(Math.sqrt(dx * dx + dy * dy), this.joystick.maxOffset);

                    const angle = Math.atan2(dy, dx);
                    this.joystickKnob.style.transform = `translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;

                    const speedRatio = (distance / this.joystick.maxOffset) * 0.95;
                    this.player.velocity.x = Math.cos(angle) * this.player.speed * speedRatio;
                    this.player.velocity.y = Math.sin(angle) * this.player.speed * speedRatio;
                }, { passive: false });

                // 触摸结束或取消：隐藏摇杆并重置速度
                const endHandler = (e) => {
                    e.preventDefault();
                    // 如果是对应触点结束
                    let ended = false;
                    for (let i = 0; i < e.changedTouches.length; i++) {
                        if (e.changedTouches[i].identifier === this.joystick.identifier) { ended = true; break; }
                    }
                    if (!ended) return;

                    this.joystick.active = false;
                    this.joystick.identifier = null;
                    this.joystickElement.style.display = 'none';
                    this.joystickKnob.style.transform = 'translate(0, 0)';
                    this.player.velocity.x = 0;
                    this.player.velocity.y = 0;
                };

                this.joystickElement.addEventListener('touchend', endHandler, { passive: false });
                this.joystickElement.addEventListener('touchcancel', endHandler, { passive: false });
            }
            
            // 加速按钮事件处理
            handleBoostStart() {
                this.keys[' '] = true;
            }
            
            handleBoostEnd() {
                this.keys[' '] = false;
            }
            
            // 开始游戏
            startGame() {
                if (this.gameState !== 'menu') return;
                
                this.gameState = 'playing';
                this.gamePaused = false;
                this.startMenu.classList.add('hidden');
                // 手机端：摇杆不在开始时固定显示，改为触点处动态显示
                if (this.isMobile) {
                    this.joystickElement.style.display = 'none';
                    this.joystickKnob.style.transform = 'translate(0, 0)';
                    this.bindJoystickEvents(); // 确保摇杆事件正确绑定
                }
            }
            
            // 切换暂停状态
            togglePause() {
                if (this.gameState === 'playing') {
                    this.pauseGame();
                } else if (this.gameState === 'paused') {
                    this.resumeGame();
                }
            }
            
            // 暂停游戏
            pauseGame() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    this.gamePaused = true;
                    this.pauseMenu.classList.remove('hidden');
                    this.pauseBtn.innerHTML = '<i class="fa fa-play text-primary text-xl"></i>';
                }
            }
            
            // 继续游戏
            resumeGame() {
                if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    this.gamePaused = false;
                    this.pauseMenu.classList.add('hidden');
                    this.pauseBtn.innerHTML = '<i class="fa fa-pause text-primary text-xl"></i>';
                }
            }
            
            // 结束游戏
            gameOver() {
                this.gameState = 'over';
                this.gamePaused = true;
                this.gameOverMenu.classList.remove('hidden');
                this.finalScoreDisplay.textContent = this.player.score;
                this.finalSizeDisplay.textContent = Math.round(this.player.radius);
            }
            
            // 重启游戏
            restartGame() {
                this.initGame();
                this.gameState = 'playing';
                this.gamePaused = false;
                this.startMenu.classList.add('hidden');
                this.pauseMenu.classList.add('hidden');
                this.gameOverMenu.classList.add('hidden');
                this.pauseBtn.innerHTML = '<i class="fa fa-pause text-primary text-xl"></i>';
                
                if (this.isMobile) {
                    this.joystickElement.style.display = 'none';
                    this.joystickKnob.style.transform = 'translate(0, 0)';
                }
            }
            
            // 更新游戏状态
            update() {
                if (this.gameState !== 'playing' || this.gamePaused) return;

                // 更新无敌状态
                if (this.player.invincible) {
                    this.player.invincibilityTimer--;
                    if (this.player.invincibilityTimer <= 0) {
                        this.player.invincible = false;
                    }
                }

                // 玩家移动控制
                this.handlePlayerMovement();

                // 分裂球运动
                this.updateSplitBalls();

                // 敌人AI移动
                this.handleEnemyMovement();

                // 碰撞检测
                this.checkCollisions();

                // 更新UI
                this.updateUI();
            }
            
            // 处理玩家移动
            handlePlayerMovement() {
                // 手机端：摇杆控制
                if (this.isMobile) {
                    // 加速处理
                    if (this.keys[' '] && this.player.radius > 15) {
                        this.player.velocity.x *= 1.3;
                        this.player.velocity.y *= 1.3;
                        this.player.radius *= (1 - this.config.boostConsumption);
                    }
                } 
                // 电脑端：键盘+鼠标控制
                else {
                    let moveX = 0;
                    let moveY = 0;
                    
                    // 键盘控制
                    if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) moveY = -1;
                    if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) moveY = 1;
                    if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) moveX = -1;
                    if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) moveX = 1;
                    
                    // 鼠标控制
                    if (this.mouse.down) {
                        const dx = this.mouse.x - this.player.x;
                        const dy = this.mouse.y - this.player.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance > 10) {
                            moveX = dx / distance;
                            moveY = dy / distance;
                        }
                    }
                    
                    // 处理移动向量
                    if (moveX !== 0 || moveY !== 0) {
                        const angle = Math.atan2(moveY, moveX);
                        let speed = this.player.speed;
                        
                        // 加速
                        if (this.keys[' '] && this.player.radius > 15) {
                            speed = this.player.maxSpeed;
                            this.player.radius *= (1 - this.config.boostConsumption);
                        }
                        
                        this.player.velocity.x = Math.cos(angle) * speed;
                        this.player.velocity.y = Math.sin(angle) * speed;
                    } else {
                        // 无输入时减速
                        this.player.velocity.x *= 0.9;
                        this.player.velocity.y *= 0.9;
                    }
                }
                
                // 世界边界检测（玩家不能超出世界）
                if (this.player.x - this.player.radius < 0) {
                    this.player.x = this.player.radius;
                    this.player.velocity.x *= this.isMobile ? -0.3 : -0.5;
                } else if (this.player.x + this.player.radius > this.worldWidth) {
                    this.player.x = this.worldWidth - this.player.radius;
                    this.player.velocity.x *= this.isMobile ? -0.3 : -0.5;
                }

                if (this.player.y - this.player.radius < 0) {
                    this.player.y = this.player.radius;
                    this.player.velocity.y *= this.isMobile ? -0.3 : -0.5;
                } else if (this.player.y + this.player.radius > this.worldHeight) {
                    this.player.y = this.worldHeight - this.player.radius;
                    this.player.velocity.y *= this.isMobile ? -0.3 : -0.5;
                }
                
                // 更新玩家位置
                this.player.x += this.player.velocity.x;
                this.player.y += this.player.velocity.y;

                // 更新摄像机，使玩家保持在视口中心
                this.camera.x = this.player.x - this.canvas.width / 2;
                this.camera.y = this.player.y - this.canvas.height / 2;
                this.clampCamera();
            }

            // 限制摄像机到世界范围，避免看到空白边缘
            clampCamera() {
                this.camera.x = Math.max(0, Math.min(this.camera.x, this.worldWidth - this.canvas.width));
                this.camera.y = Math.max(0, Math.min(this.camera.y, this.worldHeight - this.canvas.height));
            }
            
            // 处理敌人移动和分球
            handleEnemyMovement() {
                this.enemies.forEach(enemy => {
                    // 敌人分球冷却
                    if (!enemy.splitCooldown) enemy.splitCooldown = Math.floor(100 + Math.random() * 200);
                    enemy.splitCooldown--;
                    // 敌人分球条件：半径足够大且冷却到0
                    if (enemy.radius > 16 && enemy.splitCooldown <= 0) {
                        this.splitEnemy(enemy);
                        enemy.splitCooldown = Math.floor(120 + Math.random() * 200);
                    }

                    // 敌人分裂球运动
                    if (enemy.splitBalls) {
                        for (let i = enemy.splitBalls.length - 1; i >= 0; i--) {
                            const ball = enemy.splitBalls[i];
                            if (ball.timer > 0) {
                                ball.x += ball.velocity.x;
                                ball.y += ball.velocity.y;
                                ball.timer--;
                            } else {
                                // 合并回母体
                                const dx = ball.x - enemy.x;
                                const dy = ball.y - enemy.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < enemy.radius + ball.radius + 2) {
                                    enemy.radius += ball.radius;
                                    enemy.splitBalls.splice(i, 1);
                                } else {
                                    const angle = Math.atan2(enemy.y - ball.y, enemy.x - ball.x);
                                    ball.x += Math.cos(angle) * 1.1;
                                    ball.y += Math.sin(angle) * 1.1;
                                }
                            }
                        }
                    }

                    // 每30帧随机更换目标
                    if (Math.random() < 0.03) {
                        const targetType = this.isMobile ? (Math.random() < 0.8 ? 'food' : 'player') : (Math.random() < 0.5 ? 'player' : 'food');
                        if (targetType === 'player' && this.getDistance(enemy, this.player) < (this.isMobile ? 200 : 300)) {
                            enemy.target = this.player;
                        } else {
                            if (this.food.length > 0) {
                                enemy.target = this.food[Math.floor(Math.random() * this.food.length)];
                            }
                        }
                    }

                    // 向目标移动
                    if (enemy.target) {
                        const dx = enemy.target.x - enemy.x;
                        const dy = enemy.target.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance > 10) {
                            const angle = Math.atan2(dy, dx);
                            enemy.velocity.x = Math.cos(angle) * enemy.speed;
                            enemy.velocity.y = Math.sin(angle) * enemy.speed;
                        } else {
                            // 目标太近，随机移动
                            const angle = Math.random() * Math.PI * 2;
                            enemy.velocity.x = Math.cos(angle) * enemy.speed * 0.5;
                            enemy.velocity.y = Math.sin(angle) * enemy.speed * 0.5;
                        }
                    } else {
                        // 随机移动
                        const angle = Math.random() * Math.PI * 2;
                        enemy.velocity.x = Math.cos(angle) * enemy.speed * 0.5;
                        enemy.velocity.y = Math.sin(angle) * enemy.speed * 0.5;
                    }

                    // 更新敌人位置并限制在世界内
                    enemy.x += enemy.velocity.x;
                    enemy.y += enemy.velocity.y;
                    if (enemy.x - enemy.radius < 0) {
                        enemy.x = enemy.radius;
                        enemy.velocity.x *= -1;
                    } else if (enemy.x + enemy.radius > this.worldWidth) {
                        enemy.x = this.worldWidth - enemy.radius;
                        enemy.velocity.x *= -1;
                    }
                    if (enemy.y - enemy.radius < 0) {
                        enemy.y = enemy.radius;
                        enemy.velocity.y *= -1;
                    } else if (enemy.y + enemy.radius > this.worldHeight) {
                        enemy.y = this.worldHeight - enemy.radius;
                        enemy.velocity.y *= -1;
                    }
                });
            }

            // 敌人分球
            splitEnemy(enemy) {
                const minR = 8;
                const splitR = Math.max(enemy.radius / 2, minR);
                if (enemy.radius < splitR + minR) return;
                let angle = 0;
                if (Math.random() < 0.7 && this.player) {
                    angle = Math.atan2(this.player.y - enemy.y, this.player.x - enemy.x);
                } else {
                    angle = Math.random() * Math.PI * 2;
                }
                const dist = enemy.radius + splitR + 2;
                const nx = enemy.x + Math.cos(angle) * dist;
                const ny = enemy.y + Math.sin(angle) * dist;
                // 敌人分球速度也相应降低
                const speed = this.config.splitSpeed * 0.8;
                const nvx = Math.cos(angle) * speed;
                const nvy = Math.sin(angle) * speed;
                if (!enemy.splitBalls) enemy.splitBalls = [];
                enemy.splitBalls.push({
                    x: nx,
                    y: ny,
                    radius: splitR,
                    velocity: { x: nvx, y: nvy },
                    timer: 28
                });
                enemy.radius -= splitR;
            }
            
            // 检查碰撞
            checkCollisions() {
                // 玩家吃食物
                for (let i = this.food.length - 1; i >= 0; i--) {
                    const food = this.food[i];
                    const distance = Math.sqrt(
                        Math.pow(this.player.x - food.x, 2) + 
                        Math.pow(this.player.y - food.y, 2)
                    );
                    
                    if (distance < this.player.radius - food.radius) {
                        this.player.radius += food.radius * this.config.playerGrowthRate;
                        this.player.score += Math.round(food.radius);
                        this.food.splice(i, 1);
                        this.spawnFood();
                    } else {
                        // 敌人吃食物
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            const enemy = this.enemies[j];
                            const enemyDistance = Math.sqrt(
                                Math.pow(enemy.x - food.x, 2) + 
                                Math.pow(enemy.y - food.y, 2)
                            );
                            
                            if (enemyDistance < enemy.radius - food.radius) {
                                enemy.radius += food.radius * this.config.enemyGrowthRate;
                                this.food.splice(i, 1);
                                this.spawnFood();
                                break;
                            }
                        }
                    }
                }
                
                // 玩家分裂球吃食物
                if (this.splitBalls) {
                    for (let i = this.splitBalls.length - 1; i >= 0; i--) {
                        const ball = this.splitBalls[i];
                        for (let j = this.food.length - 1; j >= 0; j--) {
                            const food = this.food[j];
                            const distance = Math.sqrt(
                                Math.pow(ball.x - food.x, 2) + 
                                Math.pow(ball.y - food.y, 2)
                            );
                            
                            if (distance < ball.radius - food.radius) {
                                ball.radius += food.radius * this.config.playerGrowthRate * 0.8;
                                this.player.score += Math.round(food.radius * 0.5);
                                this.food.splice(j, 1);
                                this.spawnFood();
                                break;
                            }
                        }
                    }
                }
                
                // 玩家和敌人碰撞
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const distance = Math.sqrt(
                        Math.pow(this.player.x - enemy.x, 2) + 
                        Math.pow(this.player.y - enemy.y, 2)
                    );
                    
                    // 玩家吃敌人
                    if (distance < this.player.radius - enemy.radius && this.player.radius > enemy.radius * 1.1) {
                        this.player.radius += enemy.radius * 0.2;
                        this.player.score += Math.round(enemy.radius * 5);
                        this.enemies.splice(i, 1);
                        this.spawnEnemy();
                    } 
                    // 敌人吃玩家
                    else if (distance < enemy.radius - this.player.radius && enemy.radius > this.player.radius * 1.1 && !this.player.invincible) {
                        this.gameOver();
                        return;
                    }
                }
                
                // 分裂球和敌人碰撞
                if (this.splitBalls) {
                    for (let i = this.splitBalls.length - 1; i >= 0; i--) {
                        const ball = this.splitBalls[i];
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            const enemy = this.enemies[j];
                            const distance = Math.sqrt(
                                Math.pow(ball.x - enemy.x, 2) + 
                                Math.pow(ball.y - enemy.y, 2)
                            );
                            
                            // 分裂球吃敌人
                            if (distance < ball.radius - enemy.radius && ball.radius > enemy.radius * 1.1) {
                                ball.radius += enemy.radius * 0.2;
                                this.player.score += Math.round(enemy.radius * 3);
                                this.enemies.splice(j, 1);
                                this.spawnEnemy();
                                break;
                            } 
                            // 敌人吃分裂球
                            else if (distance < enemy.radius - ball.radius && enemy.radius > ball.radius * 1.1) {
                                enemy.radius += ball.radius * 0.2;
                                this.splitBalls.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                
                // 敌人之间的碰撞
                for (let i = 0; i < this.enemies.length; i++) {
                    for (let j = i + 1; j < this.enemies.length; j++) {
                        const enemy1 = this.enemies[i];
                        const enemy2 = this.enemies[j];
                        const distance = Math.sqrt(
                            Math.pow(enemy1.x - enemy2.x, 2) + 
                            Math.pow(enemy1.y - enemy2.y, 2)
                        );
                        
                        if (distance < enemy1.radius - enemy2.radius && enemy1.radius > enemy2.radius * 1.1) {
                            enemy1.radius += enemy2.radius * 0.2;
                            this.enemies.splice(j, 1);
                            this.spawnEnemy();
                            break;
                        } else if (distance < enemy2.radius - enemy1.radius && enemy2.radius > enemy1.radius * 1.1) {
                            enemy2.radius += enemy1.radius * 0.2;
                            this.enemies.splice(i, 1);
                            this.spawnEnemy();
                            break;
                        }
                    }
                }
            }
            
            // 更新UI显示
            updateUI() {
                this.scoreDisplay.textContent = this.player.score;
                this.sizeDisplay.textContent = Math.round(this.player.radius);
                this.enemyCountDisplay.textContent = this.enemies.length;
            }
            
            // 绘制游戏
            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 将绘制坐标系移动到摄像机位置（世界坐标 -> 视口坐标）
                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);

                // 绘制背景网格（基于世界坐标）
                this.drawBackground();

                // 绘制食物
                this.food.forEach(food => {
                    this.drawCircle(food.x, food.y, food.radius, food.color);
                });

                // 绘制敌人（使用图片或回退为圆形）
                this.enemies.forEach(enemy => {
                    this.drawEnemy(enemy);
                    // 绘制敌人分裂球
                    if (enemy.splitBalls) {
                        enemy.splitBalls.forEach(ball => {
                            const img = this.enemyImages[enemy.imageIndex];
                            this.drawImageCircle(img, ball.x, ball.y, ball.radius) || this.drawCircle(ball.x, ball.y, ball.radius, enemy.color);
                            // 绘制半径数值
                            this.ctx.fillStyle = 'white';
                            this.ctx.font = this.isMobile ? '12px Arial' : '10px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(Math.round(ball.radius), ball.x, ball.y);
                        });
                    }
                });

                // 绘制分裂球
                if (this.splitBalls) {
                    this.splitBalls.forEach(ball => {
                        this.drawImageCircle(this.playerImage, ball.x, ball.y, ball.radius) || this.drawCircle(ball.x, ball.y, ball.radius, '#EF4444');
                        // 绘制半径数值
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = this.isMobile ? '14px Arial' : '12px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(Math.round(ball.radius), ball.x, ball.y);
                    });
                }

                // 绘制玩家（使用图片替换纯色）
                this.drawPlayerWithImage();

                // 绘制玩家大小（在世界坐标系中）
                this.ctx.fillStyle = 'white';
                this.ctx.font = this.isMobile ? '14px Arial' : '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(Math.round(this.player.radius), this.player.x, this.player.y);

                this.ctx.restore();
            }
            
            // 用图片绘制玩家球
            drawPlayerWithImage() {
                if (!this.imageLoaded) {
                    // 图片加载完成前，用默认颜色绘制
                    this.ctx.fillStyle = '#EF4444';
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    return;
                }

                // 无敌状态处理（闪烁）
                if (this.player.invincible && Math.floor(Date.now() / 100) % 2 !== 0) {
                    return;
                }

                // 使用圆形裁剪绘制玩家图片，确保严格与球大小贴合
                const drawn = this.drawImageCircle(this.playerImage, this.player.x, this.player.y, this.player.radius);
                if (!drawn) {
                    // 回退为颜色圆形
                    this.ctx.fillStyle = '#EF4444';
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, this.player.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                }

                // 无敌状态外圈
                if (this.player.invincible) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = this.isMobile ? 2 : 1.5;
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, this.player.radius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
            }
            
            // 绘制背景网格
            drawBackground() {
                const gridSize = this.isMobile ? 30 : 40;
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
                this.ctx.lineWidth = 1;

                // 只绘制摄像机可见区域的网格线以提升性能
                const startX = Math.floor(this.camera.x / gridSize) * gridSize;
                const endX = Math.ceil((this.camera.x + this.canvas.width) / gridSize) * gridSize;
                const startY = Math.floor(this.camera.y / gridSize) * gridSize;
                const endY = Math.ceil((this.camera.y + this.canvas.height) / gridSize) * gridSize;

                for (let x = startX; x <= endX; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, startY);
                    this.ctx.lineTo(x, endY);
                    this.ctx.stroke();
                }

                for (let y = startY; y <= endY; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(startX, y);
                    this.ctx.lineTo(endX, y);
                    this.ctx.stroke();
                }
            }
            
            // 绘制圆形（食物和敌人）
            drawCircle(x, y, radius, color) {
                this.ctx.fillStyle = color;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // 添加高光效果
                const gradient = this.ctx.createRadialGradient(
                    x - radius * 0.3, y - radius * 0.3, radius * 0.1,
                    x, y, radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            // 绘制敌人（使用图片或回退为圆形）
            drawEnemy(enemy) {
                const img = this.enemyImages[enemy.imageIndex];

                // 使用圆形裁剪绘制图片（如果已加载），否则回退为圆形
                const drawn = this.drawImageCircle(img, enemy.x, enemy.y, enemy.radius);
                if (!drawn) {
                    this.drawCircle(enemy.x, enemy.y, enemy.radius, enemy.color);
                }

                // 手机端绘制敌人轮廓
                if (this.isMobile) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                    this.ctx.stroke();
                }

                // 绘制大小数值
                this.ctx.fillStyle = 'white';
                this.ctx.font = this.isMobile ? '12px Arial' : '10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(Math.round(enemy.radius), enemy.x, enemy.y);
            }

            // 将图片中心裁剪为正方形并以圆形掩膜绘制到指定位置，返回是否绘制成功
            drawImageCircle(img, x, y, radius) {
                if (!img || !img.complete || !img.naturalWidth) return false;

                const diameter = radius * 2;
                const iw = img.naturalWidth;
                const ih = img.naturalHeight;
                const side = Math.min(iw, ih);
                const sx = Math.floor((iw - side) / 2);
                const sy = Math.floor((ih - side) / 2);

                this.ctx.save();
                // 创建圆形裁剪区域
                this.ctx.beginPath();
                this.ctx.arc(x, y, radius, 0, Math.PI * 2);
                this.ctx.closePath();
                this.ctx.clip();

                // 将图片的中心正方形裁剪后绘制到目标圆形区域
                try {
                    this.ctx.drawImage(img, sx, sy, side, side, x - radius, y - radius, diameter, diameter);
                } catch (e) {
                    // drawImage 可能抛错（跨域或资源问题），回退并恢复上下文
                    this.ctx.restore();
                    return false;
                }

                this.ctx.restore();
                return true;
            }
            
            // 计算两点之间的距离
            getDistance(obj1, obj2) {
                const dx = obj1.x - obj2.x;
                const dy = obj1.y - obj2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            // 游戏主循环
            gameLoop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        // 页面加载完成后初始化游戏
        window.addEventListener('DOMContentLoaded', () => {
            new AgarioGame();
        });
    </script>
</body>
</html>
