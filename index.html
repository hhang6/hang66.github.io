<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>球球大作战 - 带控制按钮版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3B82F6',
                        secondary: '#10B981',
                        danger: '#EF4444',
                        dark: '#1E293B',
                        light: '#F8FAFC'
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .game-shadow {
                box-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
            }
            .pulse-glow {
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0%, 100% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.5); }
                50% { box-shadow: 0 0 25px rgba(59, 130, 246, 0.8); }
            }
            .fade-in {
                animation: fadeIn 0.5s ease-in-out;
            }
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            .joystick-active {
                transition: transform 0.1s ease;
            }
            .control-btn {
                @apply flex items-center justify-center rounded-full bg-white/10 backdrop-blur-sm border border-white/20 
                       text-white shadow-lg active:scale-95 transition-transform duration-100 touch-manipulation;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-dark to-slate-800 min-h-screen text-light flex flex-col items-center justify-center overflow-hidden p-2">
    <!-- 游戏容器 -->
    <div class="relative w-full max-w-6xl flex flex-col items-center">
        <!-- 游戏标题 -->
        <h1 class="text-[clamp(1.2rem,5vw,2.5rem)] font-bold mb-3 text-transparent bg-clip-text bg-gradient-to-r from-primary to-secondary text-center">
            球球大作战
        </h1>
        
        <!-- 游戏信息面板 -->
        <div class="w-full flex justify-between items-center mb-3 px-2 md:px-4 flex-wrap gap-2">
            <div class="bg-dark/70 backdrop-blur-sm rounded-lg px-3 py-1.5 flex items-center gap-1.5 border border-primary/30 text-sm md:text-base">
                <i class="fa fa-trophy text-yellow-400"></i>
                <span class="font-bold">得分: <span id="score" class="text-primary">0</span></span>
            </div>
            <div class="bg-dark/70 backdrop-blur-sm rounded-lg px-3 py-1.5 flex items-center gap-1.5 border border-primary/30 text-sm md:text-base">
                <i class="fa fa-circle text-danger"></i>
                <span class="font-bold">大小: <span id="size" class="text-primary">10</span></span>
            </div>
            <div class="bg-dark/70 backdrop-blur-sm rounded-lg px-3 py-1.5 flex items-center gap-1.5 border border-primary/30 text-sm md:text-base">
                <i class="fa fa-users text-secondary"></i>
                <span class="font-bold">敌人: <span id="enemy-count" class="text-primary">0</span></span>
            </div>
        </div>
        
        <!-- 游戏画布容器 -->
        <div class="relative w-full aspect-[9/16] md:aspect-[16/9] bg-slate-900 rounded-lg overflow-hidden game-shadow pulse-glow">
            <canvas id="gameCanvas" class="w-full h-full"></canvas>
            
            <!-- 通用控制按钮 (所有设备可见) -->
            <div class="absolute top-4 right-4 z-20 flex gap-2">
                <button id="pauseBtn" class="control-btn w-10 h-10 md:w-12 md:h-12">
                    <i class="fa fa-pause text-primary"></i>
                </button>
            </div>
            
            <!-- 方向控制按钮组 (移动设备为主，电脑也可显示) -->
            <div class="absolute bottom-4 left-4 flex flex-col gap-2 z-20 md:hidden">
                <div class="flex justify-center">
                    <button id="btnUp" class="control-btn w-14 h-14">
                        <i class="fa fa-arrow-up"></i>
                    </button>
                </div>
                <div class="flex gap-2">
                    <button id="btnLeft" class="control-btn w-14 h-14">
                        <i class="fa fa-arrow-left"></i>
                    </button>
                    <button id="btnDown" class="control-btn w-14 h-14">
                        <i class="fa fa-arrow-down"></i>
                    </button>
                    <button id="btnRight" class="control-btn w-14 h-14">
                        <i class="fa fa-arrow-right"></i>
                    </button>
                </div>
            </div>
            
            <!-- 功能按钮组 (所有设备可见) -->
            <div class="absolute bottom-4 right-4 flex flex-col gap-2 z-20">
                <button id="btnBoost" class="control-btn w-14 h-14 md:w-16 md:h-16 bg-danger/30 border-danger/40">
                    <i class="fa fa-bolt text-danger"></i>
                </button>
                <button id="btnRestart" class="control-btn w-14 h-14 md:w-16 md:h-16 bg-secondary/30 border-secondary/40">
                    <i class="fa fa-refresh text-secondary"></i>
                </button>
            </div>
            
            <!-- 开始菜单 -->
            <div id="startMenu" class="absolute inset-0 bg-dark/80 backdrop-blur-md flex flex-col items-center justify-center gap-6 z-10 fade-in p-4">
                <h2 class="text-[clamp(1rem,3vw,1.8rem)] font-bold text-center text-transparent bg-clip-text bg-gradient-to-r from-primary to-secondary">
                    大球吃小球
                </h2>
                <p class="text-center px-4 max-w-md text-slate-300 text-sm md:text-base">
                    控制你的球吃掉比你小的球，避开比你大的球，成为最大的球！
                </p>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 px-2 w-full max-w-md">
                    <div class="bg-slate-800/70 p-3 rounded-lg border border-primary/20 text-sm">
                        <h3 class="font-bold text-primary mb-1.5">控制方式</h3>
                        <ul class="text-slate-300 space-y-1">
                            <li><i class="fa fa-arrows mr-2 text-secondary"></i>电脑：方向键/WASD/鼠标</li>
                            <li><i class="fa fa-mobile mr-2 text-secondary"></i>手机：虚拟按键或摇杆</li>
                            <li><i class="fa fa-bolt mr-2 text-secondary"></i>加速键：消耗大小加速</li>
                            <li><i class="fa fa-pause mr-2 text-secondary"></i>暂停键：暂停游戏</li>
                        </ul>
                    </div>
                    <div class="bg-slate-800/70 p-3 rounded-lg border border-primary/20 text-sm">
                        <h3 class="font-bold text-primary mb-1.5">游戏目标</h3>
                        <ul class="text-slate-300 space-y-1">
                            <li><i class="fa fa-check-circle mr-2 text-secondary"></i>吃彩色小球增长</li>
                            <li><i class="fa fa-check-circle mr-2 text-secondary"></i>吃比你小的敌人</li>
                            <li><i class="fa fa-times-circle mr-2 text-danger"></i>避免被大球吃掉</li>
                        </ul>
                    </div>
                </div>
                <button id="startBtn" class="bg-primary hover:bg-primary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-primary/50 text-sm md:text-base">
                    开始游戏 <i class="fa fa-play ml-2"></i>
                </button>
            </div>
            
            <!-- 暂停菜单 -->
            <div id="pauseMenu" class="absolute inset-0 bg-dark/80 backdrop-blur-md flex flex-col items-center justify-center gap-6 z-10 hidden fade-in p-4">
                <h2 class="text-[clamp(1.2rem,4vw,2rem)] font-bold text-primary text-center">游戏暂停</h2>
                <p class="text-slate-300 text-center">休息一下，准备好再继续战斗吧！</p>
                <div class="flex gap-4">
                    <button id="resumeBtn" class="bg-primary hover:bg-primary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105">
                        继续游戏 <i class="fa fa-play ml-2"></i>
                    </button>
                    <button id="pauseRestartBtn" class="bg-secondary hover:bg-secondary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105">
                        重新开始 <i class="fa fa-refresh ml-2"></i>
                    </button>
                </div>
            </div>
            
            <!-- 游戏结束菜单 -->
            <div id="gameOverMenu" class="absolute inset-0 bg-dark/80 backdrop-blur-md flex flex-col items-center justify-center gap-5 z-10 hidden fade-in p-4">
                <h2 class="text-[clamp(1.2rem,4vw,2rem)] font-bold text-danger text-center">游戏结束</h2>
                <p class="text-base md:text-xl">最终得分: <span id="finalScore" class="text-primary font-bold">0</span></p>
                <p class="text-base md:text-xl">最终大小: <span id="finalSize" class="text-primary font-bold">0</span></p>
                <button id="gameOverRestartBtn" class="bg-primary hover:bg-primary/80 text-white font-bold py-2.5 px-7 rounded-full transition-all transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-primary/50 text-sm md:text-base">
                    再来一局 <i class="fa fa-refresh ml-2"></i>
                </button>
            </div>
            
            <!-- 移动设备虚拟摇杆 -->
            <div id="joystick" class="fixed bottom-32 left-5 w-28 h-28 md:hidden bg-white/10 backdrop-blur-sm rounded-full border border-white/20 hidden touch-manipulation">
                <div id="joystickKnob" class="absolute top-1/2 left-1/2 w-14 h-14 bg-primary/40 rounded-full transform -translate-x-1/2 -translate-y-1/2 touch-manipulation"></div>
            </div>
        </div>
        
        <!-- 游戏控制说明（仅电脑显示） -->
        <div class="w-full mt-3 text-center text-xs md:text-sm text-slate-400 md:block hidden">
            <p>使用 <kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">W</kbd><kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">A</kbd><kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">S</kbd><kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">D</kbd> 或方向键移动，<kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">空格</kbd> 加速，<kbd class="px-1.5 py-0.5 bg-dark rounded border border-slate-700">P</kbd> 暂停游戏</p>
        </div>
    </div>

    <script>
        // 游戏主类
        class AgarioGame {
            constructor() {
                // 获取画布和上下文
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // 设备类型判断
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                // 设置画布尺寸
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // 游戏元素
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 10,
                    color: '#EF4444',
                    speed: this.isMobile ? 2.5 : 3,
                    maxSpeed: this.isMobile ? 5 : 6,
                    velocity: { x: 0, y: 0 },
                    invincible: false,
                    invincibilityTimer: 0,
                    score: 0
                };
                
                // 游戏配置
                this.config = {
                    foodCount: this.isMobile ? 100 : 150,
                    enemyCount: this.isMobile ? 10 : 15,
                    foodMinRadius: 2,
                    foodMaxRadius: 6,
                    enemyMinRadius: 8,
                    enemyMaxRadius: 25,
                    invincibilityTime: 200,
                    boostConsumption: 0.02,
                    playerGrowthRate: 0.1,
                    enemyGrowthRate: 0.05
                };
                
                // 游戏状态
                this.gameState = 'menu'; // menu, playing, paused, over
                this.food = [];
                this.enemies = [];
                this.keys = {};
                this.mouse = { x: 0, y: 0, down: false };
                this.joystick = { 
                    active: false, 
                    startX: 0, 
                    startY: 0,
                    currentX: 0,
                    currentY: 0
                };
                
                // 虚拟按钮状态
                this.virtualButtons = {
                    up: false,
                    down: false,
                    left: false,
                    right: false,
                    boost: false
                };
                
                // 初始化游戏
                this.initGame();
                
                // 绑定事件监听
                this.bindEvents();
                
                // 游戏循环
                this.gameLoop();
            }
            
            // 调整画布尺寸
            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                // 重新定位玩家
                if (this.gameState === 'playing' || this.gameState === 'paused') {
                    this.player.x = Math.min(Math.max(this.player.x, this.player.radius), this.canvas.width - this.player.radius);
                    this.player.y = Math.min(Math.max(this.player.y, this.player.radius), this.canvas.height - this.player.radius);
                }
            }
            
            // 初始化游戏
            initGame() {
                // 重置玩家
                this.player = {
                    x: this.canvas.width / 2,
                    y: this.canvas.height / 2,
                    radius: 10,
                    color: '#EF4444',
                    speed: this.isMobile ? 2.5 : 3,
                    maxSpeed: this.isMobile ? 5 : 6,
                    velocity: { x: 0, y: 0 },
                    invincible: false,
                    invincibilityTimer: 0,
                    score: 0
                };
                
                // 生成食物
                this.food = [];
                for (let i = 0; i < this.config.foodCount; i++) {
                    this.spawnFood();
                }
                
                // 生成敌人
                this.enemies = [];
                for (let i = 0; i < this.config.enemyCount; i++) {
                    this.spawnEnemy();
                }
                
                // 更新UI
                this.updateUI();
            }
            
            // 生成食物
            spawnFood() {
                const radius = this.config.foodMinRadius + Math.random() * (this.config.foodMaxRadius - this.config.foodMinRadius);
                const x = radius + Math.random() * (this.canvas.width - 2 * radius);
                const y = radius + Math.random() * (this.canvas.height - 2 * radius);
                
                // 随机颜色
                const hue = Math.random() * 360;
                const color = `hsl(${hue}, 70%, 60%)`;
                
                this.food.push({ x, y, radius, color });
            }
            
            // 生成敌人
            spawnEnemy() {
                const radius = this.config.enemyMinRadius + Math.random() * (this.config.enemyMaxRadius - this.config.enemyMinRadius);
                let x, y;
                
                // 确保敌人不会出现在玩家附近
                do {
                    x = radius + Math.random() * (this.canvas.width - 2 * radius);
                    y = radius + Math.random() * (this.canvas.height - 2 * radius);
                } while (this.getDistance({x, y}, this.player) < this.player.radius + radius + 50);
                
                // 随机颜色
                const hue = 120 + Math.random() * 60;
                const color = this.isMobile ? `hsl(${hue}, 80%, 45%)` : `hsl(${hue}, 70%, 50%)`;
                
                this.enemies.push({
                    x, y, radius, color,
                    speed: this.isMobile ? 0.8 + Math.random() * 1.2 : 1 + Math.random() * 1.5,
                    velocity: { x: 0, y: 0 },
                    target: null
                });
            }
            
            // 绑定事件监听
            bindEvents() {
                // 键盘控制
                window.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    
                    // 暂停游戏 (P键)
                    if (e.key === 'p' || e.key === 'P') {
                        if (this.gameState === 'playing') {
                            this.pauseGame();
                        } else if (this.gameState === 'paused') {
                            this.resumeGame();
                        }
                    }
                });
                
                window.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // 鼠标控制
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });
                
                this.canvas.addEventListener('mousedown', () => {
                    this.mouse.down = true;
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.down = false;
                });
                
                // 虚拟按钮事件监听 (通用)
                // 方向键
                document.getElementById('btnUp').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.virtualButtons.up = true;
                }, { passive: false });
                document.getElementById('btnUp').addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.virtualButtons.up = true;
                });
                
                document.getElementById('btnDown').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.virtualButtons.down = true;
                }, { passive: false });
                document.getElementById('btnDown').addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.virtualButtons.down = true;
                });
                
                document.getElementById('btnLeft').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.virtualButtons.left = true;
                }, { passive: false });
                document.getElementById('btnLeft').addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.virtualButtons.left = true;
                });
                
                document.getElementById('btnRight').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.virtualButtons.right = true;
                }, { passive: false });
                document.getElementById('btnRight').addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.virtualButtons.right = true;
                });
                
                // 按钮释放事件
                document.getElementById('btnUp').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.virtualButtons.up = false;
                }, { passive: false });
                document.getElementById('btnUp').addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.virtualButtons.up = false;
                });
                document.getElementById('btnUp').addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.virtualButtons.up = false;
                });
                
                document.getElementById('btnDown').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.virtualButtons.down = false;
                }, { passive: false });
                document.getElementById('btnDown').addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.virtualButtons.down = false;
                });
                document.getElementById('btnDown').addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.virtualButtons.down = false;
                });
                
                document.getElementById('btnLeft').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.virtualButtons.left = false;
                }, { passive: false });
                document.getElementById('btnLeft').addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.virtualButtons.left = false;
                });
                document.getElementById('btnLeft').addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.virtualButtons.left = false;
                });
                
                document.getElementById('btnRight').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.virtualButtons.right = false;
                }, { passive: false });
                document.getElementById('btnRight').addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.virtualButtons.right = false;
                });
                document.getElementById('btnRight').addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.virtualButtons.right = false;
                });
                
                // 加速按钮
                document.getElementById('btnBoost').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.virtualButtons.boost = true;
                    this.keys[' '] = true;
                }, { passive: false });
                document.getElementById('btnBoost').addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.virtualButtons.boost = true;
                    this.keys[' '] = true;
                });
                
                document.getElementById('btnBoost').addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.virtualButtons.boost = false;
                    this.keys[' '] = false;
                }, { passive: false });
                document.getElementById('btnBoost').addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    this.virtualButtons.boost = false;
                    this.keys[' '] = false;
                });
                document.getElementById('btnBoost').addEventListener('mouseleave', (e) => {
                    e.preventDefault();
                    this.virtualButtons.boost = false;
                    this.keys[' '] = false;
                });
                
                // 重新开始按钮
                document.getElementById('btnRestart').addEventListener('click', () => {
                    this.restartGame();
                });
                
                // 触摸控制（摇杆）
                if (this.isMobile) {
                    const joystick = document.getElementById('joystick');
                    const joystickKnob = document.getElementById('joystickKnob');
                    
                    joystick.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const rect = joystick.getBoundingClientRect();
                        this.joystick.startX = touch.clientX;
                        this.joystick.startY = touch.clientY;
                        this.joystick.currentX = touch.clientX;
                        this.joystick.currentY = touch.clientY;
                        this.joystick.active = true;
                    }, { passive: false });
                    
                    joystick.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        if (!this.joystick.active) return;
                        
                        const touch = e.touches[0];
                        this.joystick.currentX = touch.clientX;
                        this.joystick.currentY = touch.clientY;
                        
                        const dx = this.joystick.currentX - this.joystick.startX;
                        const dy = this.joystick.currentY - this.joystick.startY;
                        const maxOffset = 35;
                        const distance = Math.min(this.getDistance(
                            {x: this.joystick.currentX, y: this.joystick.currentY},
                            {x: this.joystick.startX, y: this.joystick.startY}
                        ), maxOffset);
                        
                        const angle = Math.atan2(dy, dx);
                        joystickKnob.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * distance}px, ${Math.sin(angle) * distance}px)`;
                        
                        const speedRatio = distance / maxOffset;
                        this.player.velocity.x = Math.cos(angle) * this.player.speed * speedRatio;
                        this.player.velocity.y = Math.sin(angle) * this.player.speed * speedRatio;
                    }, { passive: false });
                    
                    joystick.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.joystick.active = false;
                        joystickKnob.style.transform = 'translate(-50%, -50%)';
                        this.player.velocity.x = 0;
                        this.player.velocity.y = 0;
                    }, { passive: false });
                }
                
                // 暂停和继续按钮
                document.getElementById('pauseBtn').addEventListener('click', () => {
                    if (this.gameState === 'playing') {
                        this.pauseGame();
                    } else if (this.gameState === 'paused') {
                        this.resumeGame();
                    }
                });
                
                document.getElementById('resumeBtn').addEventListener('click', () => {
                    this.resumeGame();
                });
                
                document.getElementById('pauseRestartBtn').addEventListener('click', () => {
                    this.restartGame();
                });
                
                // 开始和重启按钮
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startGame();
                });
                
                document.getElementById('gameOverRestartBtn').addEventListener('click', () => {
                    this.restartGame();
                });
            }
            
            // 开始游戏
            startGame() {
                this.gameState = 'playing';
                document.getElementById('startMenu').classList.add('hidden');
                
                // 手机端显示控制按钮和摇杆
                if (this.isMobile) {
                    document.getElementById('joystick').classList.remove('hidden');
                }
            }
            
            // 暂停游戏
            pauseGame() {
                if (this.gameState === 'playing') {
                    this.gameState = 'paused';
                    document.getElementById('pauseMenu').classList.remove('hidden');
                }
            }
            
            // 继续游戏
            resumeGame() {
                if (this.gameState === 'paused') {
                    this.gameState = 'playing';
                    document.getElementById('pauseMenu').classList.add('hidden');
                }
            }
            
            // 结束游戏
            gameOver() {
                this.gameState = 'over';
                document.getElementById('gameOverMenu').classList.remove('hidden');
                document.getElementById('finalScore').textContent = this.player.score;
                document.getElementById('finalSize').textContent = Math.round(this.player.radius);
            }
            
            // 重启游戏
            restartGame() {
                this.initGame();
                this.gameState = 'playing';
                document.getElementById('startMenu').classList.add('hidden');
                document.getElementById('pauseMenu').classList.add('hidden');
                document.getElementById('gameOverMenu').classList.add('hidden');
                
                if (this.isMobile) {
                    document.getElementById('joystick').classList.remove('hidden');
                }
            }
            
            // 更新游戏状态
            update() {
                if (this.gameState !== 'playing') return;
                
                // 更新无敌状态
                if (this.player.invincible) {
                    this.player.invincibilityTimer--;
                    if (this.player.invincibilityTimer <= 0) {
                        this.player.invincible = false;
                    }
                }
                
                // 玩家移动控制
                this.handlePlayerMovement();
                
                // 敌人AI移动
                this.handleEnemyMovement();
                
                // 碰撞检测
                this.checkCollisions();
                
                // 更新UI
                this.updateUI();
            }
            
            // 处理玩家移动
            handlePlayerMovement() {
                // 通用虚拟按钮控制
                let moveX = 0;
                let moveY = 0;
                
                if (this.virtualButtons.up) moveY = -1;
                if (this.virtualButtons.down) moveY = 1;
                if (this.virtualButtons.left) moveX = -1;
                if (this.virtualButtons.right) moveX = 1;
                
                // 电脑端：键盘控制（优先级低于虚拟按钮）
                if (!this.isMobile && moveX === 0 && moveY === 0) {
                    if (this.keys['ArrowUp'] || this.keys['w'] || this.keys['W']) moveY = -1;
                    if (this.keys['ArrowDown'] || this.keys['s'] || this.keys['S']) moveY = 1;
                    if (this.keys['ArrowLeft'] || this.keys['a'] || this.keys['A']) moveX = -1;
                    if (this.keys['ArrowRight'] || this.keys['d'] || this.keys['D']) moveX = 1;
                }
                
                // 电脑端：鼠标控制（优先级最高）
                if (!this.isMobile && this.mouse.down && moveX === 0 && moveY === 0) {
                    const dx = this.mouse.x - this.player.x;
                    const dy = this.mouse.y - this.player.y;
                    const distance = this.getDistance(this.mouse, this.player);
                    
                    if (distance > 10) {
                        moveX = dx / distance;
                        moveY = dy / distance;
                    }
                }
                
                // 处理移动向量
                if (moveX !== 0 || moveY !== 0) {
                    const angle = Math.atan2(moveY, moveX);
                    let speed = this.player.speed;
                    
                    // 加速（消耗大小）
                    if ((this.keys[' '] || this.virtualButtons.boost) && this.player.radius > 15) {
                        speed = this.player.maxSpeed;
                        this.player.radius *= (1 - this.config.boostConsumption);
                    }
                    
                    this.player.velocity.x = Math.cos(angle) * speed;
                    this.player.velocity.y = Math.sin(angle) * speed;
                } else if (!this.joystick.active) {
                    // 无输入时减速停止
                    this.player.velocity.x *= 0.9;
                    this.player.velocity.y *= 0.9;
                }
                
                // 手机端：摇杆控制已在事件中处理，这里仅处理加速
                if (this.isMobile && this.joystick.active) {
                    if ((this.keys[' '] || this.virtualButtons.boost) && this.player.radius > 15) {
                        this.player.velocity.x *= 1.5;
                        this.player.velocity.y *= 1.5;
                        this.player.radius *= (1 - this.config.boostConsumption);
                    }
                }
                
                // 更新玩家位置并限制在画布内
                this.player.x += this.player.velocity.x;
                this.player.y += this.player.velocity.y;
                
                // 边界碰撞检测
                if (this.player.x - this.player.radius < 0) {
                    this.player.x = this.player.radius;
                    this.player.velocity.x *= -0.5;
                } else if (this.player.x + this.player.radius > this.canvas.width) {
                    this.player.x = this.canvas.width - this.player.radius;
                    this.player.velocity.x *= -0.5;
                }
                
                if (this.player.y - this.player.radius < 0) {
                    this.player.y = this.player.radius;
                    this.player.velocity.y *= -0.5;
                } else if (this.player.y + this.player.radius > this.canvas.height) {
                    this.player.y = this.canvas.height - this.player.radius;
                    this.player.velocity.y *= -0.5;
                }
            }
            
            // 处理敌人移动
            handleEnemyMovement() {
                this.enemies.forEach(enemy => {
                    // 每30帧随机更换目标
                    if (Math.random() < 0.03) {
                        const targetType = this.isMobile ? (Math.random() < 0.7 ? 'food' : 'player') : (Math.random() < 0.5 ? 'player' : 'food');
                        
                        if (targetType === 'player' && this.getDistance(enemy, this.player) < (this.isMobile ? 250 : 300)) {
                            enemy.target = this.player;
                        } else {
                            if (this.food.length > 0) {
                                enemy.target = this.food[Math.floor(Math.random() * this.food.length)];
                            }
                        }
                    }
                    
                    // 向目标移动
                    if (enemy.target) {
                        const dx = enemy.target.x - enemy.x;
                        const dy = enemy.target.y - enemy.y;
                        const distance = this.getDistance(enemy.target, enemy);
                        
                        if (distance > 10) {
                            const angle = Math.atan2(dy, dx);
                            enemy.velocity.x = Math.cos(angle) * enemy.speed;
                            enemy.velocity.y = Math.sin(angle) * enemy.speed;
                        } else {
                            // 目标太近，随机移动
                            const angle = Math.random() * Math.PI * 2;
                            enemy.velocity.x = Math.cos(angle) * enemy.speed * 0.5;
                            enemy.velocity.y = Math.sin(angle) * enemy.speed * 0.5;
                        }
                    } else {
                        // 随机移动
                        const angle = Math.random() * Math.PI * 2;
                        enemy.velocity.x = Math.cos(angle) * enemy.speed * 0.5;
                        enemy.velocity.y = Math.sin(angle) * enemy.speed * 0.5;
                    }
                    
                    // 更新敌人位置并限制在画布内
                    enemy.x += enemy.velocity.x;
                    enemy.y += enemy.velocity.y;
                    
                    // 边界反弹
                    if (enemy.x - enemy.radius < 0) {
                        enemy.x = enemy.radius;
                        enemy.velocity.x *= -1;
                    } else if (enemy.x + enemy.radius > this.canvas.width) {
                        enemy.x = this.canvas.width - enemy.radius;
                        enemy.velocity.x *= -1;
                    }
                    
                    if (enemy.y - enemy.radius < 0) {
                        enemy.y = enemy.radius;
                        enemy.velocity.y *= -1;
                    } else if (enemy.y + enemy.radius > this.canvas.height) {
                        enemy.y = this.canvas.height - enemy.radius;
                        enemy.velocity.y *= -1;
                    }
                });
            }
            
            // 检查碰撞
            checkCollisions() {
                // 玩家吃食物
                for (let i = this.food.length - 1; i >= 0; i--) {
                    const food = this.food[i];
                    const distance = this.getDistance(this.player, food);
                    
                    if (distance < this.player.radius - food.radius) {
                        this.player.radius += food.radius * this.config.playerGrowthRate;
                        this.player.score += Math.round(food.radius);
                        this.food.splice(i, 1);
                        this.spawnFood();
                    } else {
                        // 敌人吃食物
                        for (let j = this.enemies.length - 1; j >= 0; j--) {
                            const enemy = this.enemies[j];
                            const enemyDistance = this.getDistance(enemy, food);
                            
                            if (enemyDistance < enemy.radius - food.radius) {
                                enemy.radius += food.radius * this.config.enemyGrowthRate;
                                this.food.splice(i, 1);
                                this.spawnFood();
                                break;
                            }
                        }
                    }
                }
                
                // 玩家和敌人碰撞
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    const distance = this.getDistance(this.player, enemy);
                    
                    // 玩家吃敌人
                    if (distance < this.player.radius - enemy.radius && this.player.radius > enemy.radius * 1.1) {
                        this.player.radius += enemy.radius * 0.2;
                        this.player.score += Math.round(enemy.radius * 5);
                        this.enemies.splice(i, 1);
                        this.spawnEnemy();
                    } 
                    // 敌人吃玩家
                    else if (distance < enemy.radius - this.player.radius && enemy.radius > this.player.radius * 1.1 && !this.player.invincible) {
                        this.gameOver();
                        return;
                    }
                }
                
                // 敌人之间的碰撞
                for (let i = 0; i < this.enemies.length; i++) {
                    for (let j = i + 1; j < this.enemies.length; j++) {
                        const enemy1 = this.enemies[i];
                        const enemy2 = this.enemies[j];
                        const distance = this.getDistance(enemy1, enemy2);
                        
                        if (distance < enemy1.radius - enemy2.radius && enemy1.radius > enemy2.radius * 1.1) {
                            enemy1.radius += enemy2.radius * 0.2;
                            this.enemies.splice(j, 1);
                            this.spawnEnemy();
                            break;
                        } else if (distance < enemy2.radius - enemy1.radius && enemy2.radius > enemy1.radius * 1.1) {
                            enemy2.radius += enemy1.radius * 0.2;
                            this.enemies.splice(i, 1);
                            this.spawnEnemy();
                            break;
                        }
                    }
                }
            }
            
            // 更新UI显示
            updateUI() {
                document.getElementById('score').textContent = this.player.score;
                document.getElementById('size').textContent = Math.round(this.player.radius);
                document.getElementById('enemy-count').textContent = this.enemies.length;
            }
            
            // 绘制游戏
            draw() {
                // 清空画布
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // 绘制背景网格
                this.drawBackground();
                
                // 绘制食物
                this.food.forEach(food => {
                    this.drawCircle(food.x, food.y, food.radius, food.color);
                });
                
                // 绘制敌人
                this.enemies.forEach(enemy => {
                    this.drawCircle(enemy.x, enemy.y, enemy.radius, enemy.color);
                    
                    // 手机端绘制敌人轮廓
                    if (this.isMobile) {
                        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    // 绘制大小数值
                    this.ctx.fillStyle = 'white';
                    this.ctx.font = this.isMobile ? '12px Arial' : '10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(Math.round(enemy.radius), enemy.x, enemy.y);
                });
                
                // 绘制玩家
                if (this.player.invincible) {
                    // 无敌状态闪烁效果
                    if (Math.floor(Date.now() / 100) % 2 === 0) {
                        this.drawCircle(this.player.x, this.player.y, this.player.radius, this.player.color);
                    }
                    // 无敌外圈
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    this.ctx.lineWidth = this.isMobile ? 2 : 1.5;
                    this.ctx.beginPath();
                    this.ctx.arc(this.player.x, this.player.y, this.player.radius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                } else {
                    this.drawCircle(this.player.x, this.player.y, this.player.radius, this.player.color);
                }
                
                // 绘制玩家大小
                this.ctx.fillStyle = 'white';
                this.ctx.font = this.isMobile ? '14px Arial' : '12px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(Math.round(this.player.radius), this.player.x, this.player.y);
            }
            
            // 绘制背景网格
            drawBackground() {
                const gridSize = this.isMobile ? 30 : 40;
                this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                this.ctx.lineWidth = 1;
                
                // 绘制水平线
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
